# 分布式数据库系统

主要出于以下目的,我们需要在多台机器上分布数据:
- 扩展性  
  当数据量或者读写负载巨大,严重超出了单台机器的处理上限,需要将负载分散到多台机器上。
- 容错与高可用性  
  当单台机器(或者多台,以及网络甚至整个数据中心)出现故障,还希望应用系统可以继续工作,这时需要采用多台机器提供冗余。这样某些组件失效之后,冗余组件可以迅速接管
- 延迟考虑  
  如果客户遍布世界各地,通常需要考虑在全球范围内部署服务,以方便用户就近访问最近数据中心提供的服务,从而避免数据请求跨越了半个地球才能到达目标。  

将数据分布在多节点时有两种常见的方式:  
- 复制  
  在多个节点上保存相同数据的副本,每个副本具体的存储位置可能不尽相同。复制方法可以提供冗余:如果某些节点发生不可用,则可以通过其他节点继续提供数据访问服务
- 分区  
  将一个大块头的数据拆分成多个较小的子集即分区,不同的分区分配给不同的节点(也称分片)

## 数据复制
复制主要指通过互联网络在多台机器上保存相同数据的副本。通过数据复制方案,人们通常希望达到以下目的:
- 使数据在地理位置上更接近用户,从而降低访问延迟
- 当部分组件出现故障,系统依然可以继续工作,从而提高可用性
- 扩展至多台机器以同时提供数据访问服务,从而提高吞吐量

如果复制的数据一成不变,那么复制就非常容易:只需将数据复制到每个节点,一次即可搞定,但是所有的技术挑战都在于处理持续更改的数据,我们将讨论三种流行的复制数据变化的方法:主从复制、多主节点复制和无主节点复制。
### 主节点与从节点
每个保存数据库完整数据集的节点称之为副本,当有了多个副本时不可避免的会引入一个问题:如何确保所有副本之间的数据是一致的?  
对于每一笔数据写入,所有副本都需要随之更新,否则,某些副本将出现不一致。最常见的解决方案是基于主节点的复制,也称为主从,其原理如下:  
1. 指定某一个副本为主副本,当客户写数据库时,必须将写请求首先发给主副本,主副本首先将数据写入本地存储。  
2. 其他副本则全部称为从副本,主副本把新数据写入本地存储后，然后将数据更改作为复制的日志或更改流发给所有从副本。每个从副本获得更改日志之后将其应用到本地,且严格保持与主副本相同的写入顺序。  
3. 客户端从数据库中读取时,可以在主副本或者从副本上执行查询。再次强调,只有从副本才可以接受写请求,从客户端的角度来看,从副本都是只读的
   
通常把所有的节点配置为同步复制是不切实际的,因为这样 会导致任何一个同步节点的中端都会导致整个系统更新停滞不前。实践中,如果数据库启用同步复制,通常意味着其中一个从节点是同步的,而其他节点则是异步模式。万一同步的从节点变得不可用或性能下降，则把另一个异步的从节点提升为同步模式,这也称为半同步。
#### 配置新的从节点
如果需要增加副本数以提高容错能力,或者替换失败的副本,就需要考虑增加新的从节点。那么又如何确保新的从节点和主节点保持数据一致呢?  
简单的拷贝时不够的,因为数据是在不断变化,等你拷贝-完成的过程中数据又产生了变化,除非你把整个服务器先杀死,但这样就违背了高可用原则,所以在不停机、数据服务不中断的前提下完成从节点的设置的逻辑:
1. 在某个时间点先产生一个一致性快照
2. 拷贝快照到从节点
3. 从节点连接到主节点并请求快照点之后所发生的数据更改日志。
4. 获得日志后,从节点应用这些快照点之后所有的数据变更,这个过程称为追赶,接下来就可以继续处理主节点上新的数据变化,并重复1-4步骤
### 处理节点失效
目标:尽管个别节点会出现中断,但要保持系统总体的持续运行并尽可能减小节点中断带来的影响,利用主从复制技术来实现系统高可用:  
1. 主节点失效: 追赶式恢复。从节点的本地磁盘上都保存了副本收到的数据变更日志。如果从节点奔溃而后顺利重启,或者主从节点之间的网络发生暂时中断,则恢复比较容易,根据副本的复制日志,从节点可以知道在发生故障所处理的最后一笔事务,然后连接到主节点,并请求自那笔事务之后中断期间内所有的数据变更。在收到这些数据变更日志之后,将其应用到本地来追赶主节点。之后就和正常情况一样持续接收来自主节点数据流的变化。
2. 主节点失效: 节点切换。选择某个从节点将其提升为主节点;客户端也需要更新,这样之后的写请求会发生给新的主节点,然后其他从节点要接受来自新的主节点上的变更数据,这一过程称为切换。故障切换可以手动也可以自动,自动选择步骤如下:  
   - 确认主节点失效
   - 选择新的主节点
   - 重新配置系统使新主节点生效

## 复制日志的实现
最简单的情况,主节点记录所执行的每个写请求(操作语句)并将该操作语句作为日志发送给从节点。对于关系数据库,这意味着insert,update,delete语句都会转发给从节点,并且每个从节点都会执行这些语句,就跟接到客户端操作一样。但这种方法有如下不适用场景:
- 任何调用非确定性函数,例如now()、rand(),会造成不同副本上不同的值
- 使用自增列
- 有副作用的语句(例如触发器、存储过程、自定义函数),可能会在每个副本上产生不同的副作用
  
当然可以使用特殊的方法来解决,例如把非确定性替换为确定性。但是这存在太多的因素要考虑,所以通常不使用

## 基于预写日志(WAL)传输
通常每个写操作都是以追加写的方式写入到日志中

## 基于行的逻辑日志复制

## 基于触发器的复制