# 分布式数据库系统

主要出于以下目的,我们需要在多台机器上分布数据:
- 扩展性  
  当数据量或者读写负载巨大,严重超出了单台机器的处理上限,需要将负载分散到多台机器上。
- 容错与高可用性  
  当单台机器(或者多台,以及网络甚至整个数据中心)出现故障,还希望应用系统可以继续工作,这时需要采用多台机器提供冗余。这样某些组件失效之后,冗余组件可以迅速接管
- 延迟考虑  
  如果客户遍布世界各地,通常需要考虑在全球范围内部署服务,以方便用户就近访问最近数据中心提供的服务,从而避免数据请求跨越了半个地球才能到达目标。  

将数据分布在多节点时有两种常见的方式:  
- 复制  
  在多个节点上保存相同数据的副本,每个副本具体的存储位置可能不尽相同。复制方法可以提供冗余:如果某些节点发生不可用,则可以通过其他节点继续提供数据访问服务
- 分区  
  将一个大块头的数据拆分成多个较小的子集即分区,不同的分区分配给不同的节点(也称分片)

## 数据复制

复制主要指通过互联网络在多台机器上保存相同数据的副本。通过数据复制方案，人们通常希望达到以下的目的
- 使数据在地理位置上更接近用户，从而降低访问延迟
- 当部分组件出现故障，系统依然可以继续工作，提高可用性
- 扩展多台机器以同时提供数据访问服务，从而提高吞吐量

本章节主要讨论规模较小、集群的每一台机器都可以保存数据集的完整副本。如果复制的数据一成不变，那么复制就是非常容易的：只需要将数据复制到每个节点，一次就搞定了，然而所有的技术挑战都在于处理那些持续更改的数据，而这正是本章讨论的核心。我们将讨论三种流行的复制数据变化的方法：主从复制、多节点主从复制和无节点复制。几乎所有的分布式数据库都是使用上述方法的一种，而三种方法各有优缺点。

数据库复制其实是个很古老的话题，因为网络的基本约束条件没有发生本质的改变。实践中很多开发人员仍然假定数据库只运行在单节点上，分布式数据库称为主流也只是最近发生的事情。由于很多应用开发人员在这方面经验不足，对注入最终一致性等问题存在一些误解，因此在复制滞后问题中，我们会详细讨论最终一致性，包括读自己的写和单调读等。
### 主节点与从节点
每个保存数据库完整数据集的节点称之为副本,当有了多个副本时不可避免的会引入一个问题:如何确保所有副本之间的数据是一致的?  
对于每一笔数据写入,所有副本都需要随之更新,否则,某些副本将出现不一致。最常见的解决方案是基于主节点的复制,也称为主从,其原理如下:  
1. 指定某一个副本为主副本,当客户写数据库时,必须将写请求首先发给主副本,主副本首先将数据写入本地存储。  
2. 其他副本则全部称为从副本,主副本把新数据写入本地存储后，然后将数据更改作为复制的日志或更改流发给所有从副本。每个从副本获得更改日志之后将其应用到本地,且严格保持与主副本相同的写入顺序。  
3. 客户端从数据库中读取时,可以在主副本或者从副本上执行查询。再次强调,只有从副本才可以接受写请求,从客户端的角度来看,从副本都是只读的
   
通常把所有的节点配置为同步复制是不切实际的,因为这样 会导致任何一个同步节点的中端都会导致整个系统更新停滞不前。实践中,如果数据库启用同步复制,通常意味着其中一个从节点是同步的,而其他节点则是异步模式。万一同步的从节点变得不可用或性能下降，则把另一个异步的从节点提升为同步模式,这也称为半同步。
#### 配置新的从节点
如果需要增加副本数以提高容错能力,或者替换失败的副本,就需要考虑增加新的从节点。那么又如何确保新的从节点和主节点保持数据一致呢?  
简单的拷贝时不够的,因为数据是在不断变化,等你拷贝-完成的过程中数据又产生了变化,除非你把整个服务器先杀死,但这样就违背了高可用原则,所以在不停机、数据服务不中断的前提下完成从节点的设置的逻辑:
1. 在某个时间点先产生一个一致性快照
2. 拷贝快照到从节点
3. 从节点连接到主节点并请求快照点之后所发生的数据更改日志。
4. 获得日志后,从节点应用这些快照点之后所有的数据变更,这个过程称为追赶,接下来就可以继续处理主节点上新的数据变化,并重复1-4步骤
### 处理节点失效
目标:尽管个别节点会出现中断,但要保持系统总体的持续运行并尽可能减小节点中断带来的影响,利用主从复制技术来实现系统高可用:  
1. 主节点失效: 追赶式恢复。从节点的本地磁盘上都保存了副本收到的数据变更日志。如果从节点奔溃而后顺利重启,或者主从节点之间的网络发生暂时中断,则恢复比较容易,根据副本的复制日志,从节点可以知道在发生故障所处理的最后一笔事务,然后连接到主节点,并请求自那笔事务之后中断期间内所有的数据变更。在收到这些数据变更日志之后,将其应用到本地来追赶主节点。之后就和正常情况一样持续接收来自主节点数据流的变化。
2. 主节点失效: 节点切换。选择某个从节点将其提升为主节点;客户端也需要更新,这样之后的写请求会发生给新的主节点,然后其他从节点要接受来自新的主节点上的变更数据,这一过程称为切换。故障切换可以手动也可以自动,自动选择步骤如下:  
   - 确认主节点失效
   - 选择新的主节点
   - 重新配置系统使新主节点生效

## 复制日志的实现
最简单的情况,主节点记录所执行的每个写请求(操作语句)并将该操作语句作为日志发送给从节点。对于关系数据库,这意味着insert,update,delete语句都会转发给从节点,并且每个从节点都会执行这些语句,就跟接到客户端操作一样。但这种方法有如下不适用场景:
- 任何调用非确定性函数,例如now()、rand(),会造成不同副本上不同的值
- 使用自增列
- 有副作用的语句(例如触发器、存储过程、自定义函数),可能会在每个副本上产生不同的副作用
  
当然可以使用特殊的方法来解决,例如把非确定性替换为确定性。但是这存在太多的因素要考虑,所以通常不使用

## 基于预写日志(WAL)传输
通常每个写操作都是以追加写的方式写入到日志中

## 单调读
单调读是一个比强一致性弱,但比最终一致性强的保证,当读取数据时,单调读保证,如果某个用户依次进行多次读取,则他绝不会看到回滚现象,即在读取较新值之后又发送读取旧值的情况,实现单调读的一种方式是,确保每个用户总是从固定的同一副本执行读取(而不同的用户可以从不同的副本读取)。例如,基于用户ID的哈希方法而不是随机选择副本。但如果该副本发送失效,则用户的查询必须重新路由到另一个副本
## 前缀一致读
举个例子由于复制滞后导致因果反常的例子:  
<div align="center">
A: B夫人,您能看到多远的未来<br/>
B: 通常约为10s  
</div>

现在第三个人正在通过节点收听上诉对话,B夫人有延迟,而A有更长的延迟就会变为:  
<div align="center">
B: 通常约为10s  <br/>
A: B夫人,您能看到多远的未来

</div>
显然逻辑上存在混乱,为了防止这种异常需要引入另一种保证:前缀一致读,该保证是说对于一系列按照某个顺序发送的写请求,那么读取这些内容时也会按照当时写入的顺序,这是分区分片数据库中出现的一个特殊问题,细节问题将在第六章讨论。如果数据库总是以相同的顺序写入,则读取总是看到一致的序列,不会发生这种问题,然而许多分布式数据库中,不同的分区独立运行,因此不存在全局写入顺序。这导致当用户从数据库中读数据时可能会看到数据库的某部分旧值和另一部分新值。  
一个解决方案是确保任何具有因果顺序关系的写入都交给一个分区来完成,但该方案真实实现效率会大打折扣。