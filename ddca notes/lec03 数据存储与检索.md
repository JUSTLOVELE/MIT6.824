从最基本的层面看,数据库只需要做两件事情:向它插入数据时,它就保存数据;之后查询时,它应该返回那些数据。  
这里要探讨的是如何存储输入的数据，并在接收到查询请求时怎样重新找到数据  
## 索引  
数据库的核心功能就是存储和查询,一个最简单的数据库:有两个函数db_set(key,value),db_get(key),如果数据库中存储了大量的记录,db_get的性能就会很差,开销是O(N),N很大则每次都要全表扫描。  
为了高效的查找数据库中特定键的值，需要新的数据结构：索引,索引的结构有很多种,它们背后的基本想法都是保留一些额外的元数据,这些元数据作为路标,帮助定位想要的数据。  
索引是基于原始数据派生而来的额外数据结构。很多数据库允许单独添加和删除索引，而不影响数据库内容，它只会影响查询性能。维护额外的结构势必会引入开销，特别是在新数据写入时。对于写入，它很难超过简单地追加文件方式的性能，因为那已经是最简单的写操作了。由于每次写数据时需要更新索引，因此任何类型的索引通常都会降低写的速度。  
其实这里涉及存储系统中重要的权衡设计:适当的索引可以加速读取查询，但每个索引都会减慢写速度。因此默认情况下，数据库通常不会对所有内容进行索引，需要后期开发人员手动选择索引。为的是给程序提供最有利的加速同时，避免银过多不必要的开销。
### 哈希索引  
key-value存储于大多数编程语言内置的字典结构非常相似,通常采用hash map来实现，也就是说当在文件中追加新的key-value对时,还要更新hash map来反映刚刚写入数据的偏移量(包括插入新的键和更新已有的键)。当查找某个值时，使用hash map来找到文件中的偏移量，即存储位置，然后读取其内容，这也是Bitcask所采用的核心做法。   
哈希表索引也有其局限性:
- 哈希表必须全部放入内存,所以如果有大量的键,就没那么幸运了。原则上可以在磁盘上维护hash map,但不幸的是,很难使磁盘上的hash map表现良好。它需要大量的随机访问I/O,当哈希变满时,继续增长代价昂贵,并且哈希冲突时需要复杂的处理逻辑。
- 区间查询效率不高。例如，不能简单地支持扫描kitty000000和kitty999999区间内的所有键,只能采用逐个查找的方式查询每一个键。 